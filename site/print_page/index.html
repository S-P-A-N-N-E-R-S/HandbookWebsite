<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="canonical" href="https://example.com/print_page/">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Print Site - S.P.A.N.N.E.R.S.-Plugin</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  <link href="/css/print-site.css" rel="stylesheet" />
  <link href="/extra.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Print Site";
    var mkdocs_page_input_path = "print_page.md";
    var mkdocs_page_url = "/print_page/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 

        <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', function () {
            remove_material_navigation();remove_mkdocs_theme_navigation();generate_toc();
        })
        </script>
        </head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> S.P.A.N.N.E.R.S.-Plugin</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="//search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Setup</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../docker/">Using Docker</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../git/">Using Git</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Beginner's Guide</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../ui/">User Interface</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../graphbuilder/">Graph Builder</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../graphlayer/">Graph Layer</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Advanced Applications</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../handlers/">Generating Your Own Handlers</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../testing/">Testing Your Results</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">About the S.P.A.N.N.E.R.S.-Plugin</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../licenses/">Licenses</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../about/">About</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">S.P.A.N.N.E.R.S.-Plugin</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Print Site</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <div id="print-site-page" class="print-site-enumerate-headings print-site-enumerate-figures">
        <section class="print-page">
            <div id="print-page-toc" data-toc-depth="3">
                <nav role='navigation' class='print-page-toc-nav'>
                <h1 class='print-page-toc-title'>Table of Contents</h1>
                </nav>
            </div>
        </section>
        <section class="print-page" id="index"><h1 id="index-welcome-to-the-spanners-plugin-documentation">Welcome to the S.P.A.N.N.E.R.S.-Plugin-Documentation!</h1>
<p><img style="float: right;" src="../img/logo.png" width="200"></p>
<p>We provide a possibility to connect the (open-source) geographic information system <a href="https://www.qgis.org/en/site/">QGIS</a> with the open graph drawing framework <a href="https://ogdf.uos.de/">OGDF</a>.</p>
<p>Graph algorithm engineers can embed new graph algorithms in the OGDF and test them on real life instances extracted from map data. QGIS enthusiasts can also browse through a range of efficient algorithms already provided in the OGDF and perform various tasks with them.</p>
<p>With our plugin, you can also perform customisable experiments and automatically visualise the results in a scientific manner.
If you want to use the S.P.A.N.N.E.R.S.-Plugin you can either enjoy the easy installation process with our docker image or you can follow our installation guide by manually installing the individual components.</p>
<p>When you're all set, you can start with the <a href="#ui">Beginner's Guide</a><!--change if navigation is changed-->. Later on, you can also check out our guide for <a href="#handlers">Advanced Applications</a>.</p>
<p>Good luck and have fun! üòè</p></section>
                        <h1 class='nav-section-title' id='section-setup'>
                            Setup <a class='headerlink' href='#section-setup' title='Permanent link'>‚Üµ</a>
                        </h1>
                        <section class="print-page" id="docker"><h1 id="docker-using-docker">Using Docker</h1>
<p>Work In Progress</p></section><section class="print-page" id="git"><h1 id="git-using-git">Using Git</h1>
<p>Work In Progress</p></section><h1 class='nav-section-title-end'>Ended: Setup</h1>
                        <h1 class='nav-section-title' id='section-beginner-s-guide'>
                            Beginner's Guide <a class='headerlink' href='#section-beginner-s-guide' title='Permanent link'>‚Üµ</a>
                        </h1>
                        <section class="print-page" id="ui"><h1 id="ui-user-interface">User Interface</h1>
<p>The user interface consists of different windows that provide various functions, such as creating or editing graphs. All functions of the plugin are available through the user interface. </p>
<p>The section <a href="#ui-open-plugin-main-window">Open Plugin Main Window</a> shows how to open the main window of the plugin and the window of the graph layer. After you know how to open the windows, the components of the main window will be presented in the section <a href="#ui-plugin-window-overview">Plugin Window Overview</a>. For more information on the graph layer, see the chapter on <a href="#graphlayer">graph layers</a>.</p>
<h2 id="ui-open-plugin-main-window">Open Plugin Main Window</h2>
<p>The main window looks like this:</p>
<p><a name = "mainwindow">
    <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/main_window_resource.png" target="_blank"><img alt="The Main Mindow" src="../img/main_window_resource.png" /></a>
</a></p>
<p>and can be opened in two different ways:</p>
<h3 id="ui-menu-bar">Menu Bar</h3>
<p>In the menu bar, the window can be opened under <code>Plugins -&gt; OGDF Plugin</code>. The menu item has several entries that correspond to the tabs presented in the section <a href="#ui-plugin-window-overview">Plugin Window Overview</a>.</p>
<h3 id="ui-plugin-toolbar">Plugin Toolbar</h3>
<p>Another possibility to open the window is through the <em>plugin toolbar</em> by clicking on the plugin logo or on the arrow next to the logo to directly open a selected tab.</p>
<p>Both options are highlighted in the image below:</p>
<p><a name="openpluginwindow">
    <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/open_plugin_window.png" target="_blank"><img alt="Options to open the main window are highlighted in red" src="../img/open_plugin_window.png" /></a>
</a></p>
<h2 id="ui-open-graph-layer-window">Open Graph Layer Window</h2>
<p>The following Graph Layer Window can be accessed by simply double-clicking on the desired layer in the layers panel. Alternatively, the window can be opened by right-clicking on the layer in the <em>layers panel</em> and selecting the menu entry <code>properties...</code>.</p>
<p><center>
    <a name="graphlayerwindow">
        <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/graph_layer_window.png" target="_blank"><img alt="Graph Layer Window" src="../img/graph_layer_window.png" /></a>
    </a>
</center></p>
<h2 id="ui-plugin-window-overview">Plugin Window Overview</h2>
<p>The main window provides a navigation on the left hand side. There are multiple tabs inserted which will all be described separately in the following paragraphs. You can navigate to the content of a tab by simply clicking on the desired tab.</p>
<h3 id="ui-create-from-resource-tab">Create From Resource Tab</h3>
<p>On the <em>Create from resource tab</em>, which is directly chosen when you open the plugin (see the <a href="#ui-mainwindow">image above</a>), you can load a layer from a predefined data set into the QGIS canvas. This can be done by selecting a data set from the drop-down list and then selecting a storage location of the layer. By clicking the <code>Create</code> button, the predefined data set will be created in the selected location and loaded as a layer to be rendered in QGIS. The predefined data sets contain various real open data vector and raster data for testing purposes and are described in the following.</p>
<ul>
<li><strong>airports:</strong> The <em>airports</em> data set contains 3187 large and medium airports around the world represented by point features. Each airport has information about codenames, elevation, frequency, runways and wikipedia links. This data set is in the public domain and can be used, for example, to create a graph from this point layer. More details concerning this data set can be found under <a href="https://hub.arcgis.com/datasets/esri-de-content::world-airports/about">this link</a>.</li>
<li><strong>berlin elevation:</strong> The <em>berlin elevation</em> data set contains a digital elevation model of Berlin. The data is stored in the Tag Image File Format (TIFF) and is licensed under the Open Data Commons Open Database License (ODbL). It can be used to build cost functions. More details concerning this data set can be found under <a href="https://www.opendem.info/download_srtm.html">this link</a>.</li>
<li><strong>berlin environmental zone:</strong> This data set provides one polygon of the environmental zone of Berlin. The data is licensed under Data licence Germany ‚Äì attribution ‚Äì Version 2.0 and can be used, for example, in cost functions of weighted graphs or to simulate forbidden area. More details concerning this data set under <a href="https://hub.arcgis.com/datasets/esri-de-content::umweltzone-berlin/about">this link</a>.</li>
<li><strong>berlin streets:</strong> This data set offers a detailed street network of Berlin represented by a line layer with 42568 streets. The streets contain various information such as street name and type. The data is licensed under Data licence Germany ‚Äì attribution ‚Äì Version 2.0 and can be used, for example, to create a graph from this line layer. More details concerning this data set can be found under <a href="https://hub.arcgis.com/datasets/esri-de-content::stra%C3%9Fennetz-berlin/about?layer=1">this link</a>.</li>
<li><strong>brandenburg nature reserves:</strong> The <em>brandenburg nature reserves</em> data set consists of 621 polygons representing nature reserves in Brandenburg. The data is licensed under Data licence Germany ‚Äì attribution ‚Äì Version 2.0 and can be used, for example, in cost functions or to simulate forbidden area. More details concerning this data set can be found under <a href="https://hub.arcgis.com/maps/esri-de-content::schutzgebiete-brandenburg/about">this link</a>.</li>
<li><strong>brandenburg water conservation areas:</strong> This data set includes 2040 water conservation areas represented as polygon layers. The data is licensed under Data licence Germany ‚Äì attribution ‚Äì Version 2.0 and can be used, for example, in cost functions of weighted graphs. More details concerning this data set can be found under <a href="https://hub.arcgis.com/datasets/esri-de-content::wasserschutzgebiete-brandenburg/about">this link</a>.</li>
</ul>
<h3 id="ui-create-graph-tab">Create Graph Tab</h3>
<p>The <em>Create graph tab</em> shown below allows to create graphs from one input layer or a <code>.graphml</code> file. Since there exist many input options, the creation of the graph is more complex and is explained in detail in the <a href="#graphbuilder">Graph Builder section</a>.</p>
<p><a name="creategraph">
    <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/Plugin_CreateGraph.png" target="_blank"><img alt="Cost Function Widget" src="../img/Plugin_CreateGraph.png" /></a>
</a></p>
<p>The contents of the tab are split into different tabs that provide various functions. The <em>Parameters tab</em> contains all the input fields for creating a graph, which is created after clicking the <code>Create</code> button. The <em>Graph Tasks tab</em> displays a table that lists information about all running and completed graph creation processes and allows to cancel a process. Also, it is possible to create at most three graphs simultaneously in the background by clicking the <code>create graph</code><!--nachschauen--> button several times. The <em>Log tab</em> outputs logging information in a text browser.</p>
<h3 id="ui-ogdf-analysis-tab">OGDF Analysis Tab</h3>
<p>After you have created a graph, you can send it to the OGDF server for analysis in the <em>OGDF analysis tab</em> and fetch the result of the analysis in the <em>OGDF jobs tab</em>. As you can see below, the view has two tabs.</p>
<p><a name="graphlayerwindow">
    <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/main_window_analysis.png" target="_blank"><img alt="Analysis Tab" src="../img/main_window_analysis.png" /></a>
</a></p>
<p>On the <em>Parameters tab</em> you can specify the analysis and the corresponding analysis parameters. The <em>Log tab</em> provides logging information. After clicking the <code>Run job</code> button, your data will be sent to the server, where the analysis will be performed. As explained in the chapter on <a href="#handlers">generating your own handlers</a>, analyses can be added. The following analyses are provided by default:</p>
<!--Zitation???-->
<ul>
<li><strong>Greedy Spanner:</strong> The greedy spanner analysis calculates a <script type="math/tex">(2k-1)</script>-spanner of a given graph using the basic greedy <script type="math/tex">(2k-1)</script>-spanner algorithm by Alth√∂fer et al., 2007. The multiplicative spanner is constructed by greedily adding edges. The algorithm takes an undirected weighted graph, its edge costs and a stretch factor <script type="math/tex">\geq 1</script> for the multiplicative distortion function as input.  </li>
<li><strong>Berman Spanner:</strong> The Berman spanner analysis calculates a <script type="math/tex">k</script>-spanner with an approximation ratio of <script type="math/tex">\mathcal{O}(n^{1/2}\log n)</script> based on Berman et. al., 2013. The analysis takes a simple connected graph, the edge costs of the graph and a stretch factor <script type="math/tex">\geq 1</script> for the multiplicative distortion function as input.  </li>
<li><strong>Convex Hull:</strong> This analysis determines the convex hull of the selected graph and delivers the convex hull as a graph.  </li>
<li><strong>Dijkstra:</strong> The Dijkstra analysis performs Dijkstra's single source shortest path algorithm on the given graph. The analysis takes a graph with positive edge weights, the graph's edge costs and a start node as input. The resulting graph contains all shortest paths starting from the start node.  </li>
<li><strong>Todo:</strong> Add new ones ...</li>
</ul>
<h3 id="ui-benchmarks-tab">Benchmarks Tab</h3>
<p>The Benchmark System gives you the possibility to execute experiments using the graphs you created. For more details, see the <a href="#testing">Testing Your Results chapter</a>.</p>
<h3 id="ui-ogdf-jobs-tab">OGDF Jobs Tab</h3>
<p>As mentioned above, in the <em>OGDF jobs tab</em> you can view the status of your running jobs and fetch the results of your successfully completed jobs from the server. In addition, you can cancel jobs, restart them and fetch the original graph of the analysis from the server. The tab is displayed below:</p>
<p><center>
    <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/main_window_jobs.png" target="_blank"><img alt="Main Window Jobs" src="../img/main_window_jobs.png" /></a>
</center></p>
<h3 id="ui-options-tab">Options tab</h3>
<p>The <em>Options tab</em> is shown below and allows to specify general settings for the plugin. You can specify server settings, like host or port and authentication settings, like username or password. After confirming the <code>Save</code> button, the settings will be persistently saved in QGIS. The following server settings can be set:</p>
<p><center>
    <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/main_window_options.png" target="blank"><img alt="Main Window Jobs" src="../img/main_window_options.png" /></a>
</center></p>
<ul>
<li><strong>Host:</strong> Specifies the host address of the server. The default value is <code>localhost</code>  </li>
<li><strong>Port:</strong> Contains the port number of the server. The default number is <code>4711</code>.  </li>
<li><strong>Username:</strong> The username is used to identify yourself to the server.  </li>
<li><strong>Password:</strong> The password to access the server.</li>
</ul></section><section class="print-page" id="graphbuilder"><h1 id="graphbuilder-graph-builder">Graph Builder</h1>
<p>As the main field of use for the plugin is creating graph instances, the following sections will explain how to use the plugin to create such graphs. </p>
<p>The figure below shows the user interface for the graph creation process which you can access in our OGDF-Plugin by accessing the <em>Create graph tab</em>.
Different areas are highlighted and referenced throughout the following sections.</p>
<p><a name = "createGraph">
    <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/Plugin_CreateGraph.png" target="_blank"><img alt="The Main Mindow" src="../img/Plugin_CreateGraph.png" /></a>
</a></p>
<!--- TODO: richtige Links f√ºr vector layer etc finden  --->
<!--- TODO: Cost Function Window schr√§g?  --->

<!--- TODO: OGDF-Plugin?  --->

<h2 id="graphbuilder-vector-layer">Vector Layer</h2>
<p>You can add a vector layer at the top of area 1. It's possible to use line layers and point layers, or you can choose to recreate a graph from the set of available file formats (see the <a href="#graphlayer-graph-export">Graph Export section</a>). If you insert a line layer, every end point of a line will be a graph vertex and an edge is inserted between connected points. If you insert a point layer, the points will be vertices in the graph, but no information about the connection is available. This is why you have to define a <em>connection type</em> in area 3. All the different <em>connection type</em> options will be explained in the <a href="#graphbuilder-connection-type">according section</a>.
By using  a line layer as input, you can also draw your own graph on the <a href="https://docs.qgis.org/3.16/en/docs/pyqgis_developer_cookbook/canvas.html">QGIS-Canvas</a> or create a variety of different special types of graphs. For the latter, you need to use a set of QGIS-tools you can select from the <a href="https://docs.qgis.org/3.4/de/docs/user_manual/processing/toolbox.html">Processing Toolbox</a> directly in QGIS. </p>
<h2 id="graphbuilder-random-graph">Random Graph</h2>
<p>If you don't want to use a vector layer as basis for the graph, it's possible to use a set of random vertices instead by checking the <code>Random graph</code> checkbox in area 1. In area 2 you can define different additional properties of the random points, such as the number of vertices and the area in which the vertices should be placed. There are some predefined possibilities for the area, but you can define your own custom area as well. </p>
<p>The last option for a random graph is an optional seed you can provide in order to replicate past results.
The seed of an existing graph can be seen in the <em>graph layer window</em> of the corresponding graph layer. The <a href="https://docs.qgis.org/3.16/en/docs/training_manual/processing/crs.html">carrier routing system (CRS)</a> of the created <code>GraphLayer</code> is set to <code>EPSG:4326</code> by default. The CRS is changed by defining your own custom area. In this case, the CRS is set to the project-CRS. </p>
<h2 id="graphbuilder-connection-type">Connection Type</h2>
<p>If you use a point vector layer or random points as basis for the graph, you need to choose how you want to connect these points. The following list shows all available options for the <em>connection type</em>.</p>
<ul>
<li><strong><code>Nearest Neighbor</code>:</strong> Connects every vertex to its nearest points. You can define the number of neighbours in area 3 as well. Additionally, it's possible to allow double edges by selecting the checkbox in area 3 next to the number of the <code>Nearest Neighbour</code> field.
As the name suggests, this allows the existence of edges going into both directions. If this option is enabled, a graph with 10 vertices and 3 nearest neighbours has 30 edges. If the option is disabled, the amount of edges is smaller because it's not possible to find the given number of neighbours for the last vertices. Note that the resulting graph differs depending on your setting of the edge direction in area 4. If you select <code>directed</code>, the amount of edges will be higher than in case of undirected edges. This is because
in the undirected case, no edges will be inserted for a node which already has the desired amount of edges. Another thing to keep in mind is that a directed graph is acyclic whenever you did not allow double edges because for every processed node, only outgoing edges are inserted and afterwards the node is deleted, so no entering edge can be inserted.</li>
<li><strong><code>Complete</code>:</strong> Connects every pair of vertices to a fully connected graph. Note that the graph is different depending on your setting of the edge direction in area 4. The amount of edges will be twice as high if you select <code>directed</code> because every edge is inserted into both directions which leads to a higher memory consumption and to a longer creation process. </li>
<li><strong><code>ClusterComplete</code>:</strong> Creates a set of clusters. In area 3 you can define the amount of clusters. Every vertex inside the same cluster is connected with every other vertex in the same cluster. As with the normal complete graph, the graph is dependent on the setting of the edge direction in area 4. </li>
<li><strong><code>ClusterNN</code>:</strong> Creates a set of clusters. Every vertex is only connected to vertices in the same clusters. In contrast to the <code>ClusterComplete</code> connection, every vertex is connected to its nearest neighbours. For this reason, all the options for the <code>Nearest Neighbor</code> connection apply. </li>
<li><strong><code>DistanceNN</code>:</strong> Connects every vertex to every other vertex, which is in a specified distance to the vertex. You can define this distance in area 3. It's possible to set the distance in different units. If the CRS of the input vector layer uses degrees as units, the only unit possible is degrees. In case the input layer uses meters, you can choose from 8 different units. You can again allow double edges for directed graphs.</li>
<li><strong><code>Random</code>:</strong> Creates random connections. You can specify the amount of random edges in area 3.</li>
</ul>
<h2 id="graphbuilder-drawn-graphs-and-grid-graphs">Drawn Graphs and Grid Graphs</h2>
<p>You can use QGIS to draw your own graph on the Canvas and you can use our tool to create special types of graphs like
grid graphs.</p>
<h4 id="graphbuilder-draw-your-own-graph">Draw Your Own Graph</h4>
<p>To start with, go to <code>Layer -&gt; CreateLayer -&gt; New Shapefile Layer</code>. In the window, select <code>LineString</code> as geometry type, a file name and a CRS. Next, you have to turn on the editing mode by clicking on the <code>Toggle Editing</code> button in the <em>toolbar</em>. The button is
highlighted in the image below: </p>
<p><center>  <br />
<a name = "toggleEditing">
    <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/Toggle_Editing_Selection.png" target="_blank"><img alt="Toggle Editing" src="../img/Toggle_Editing_Selection.png" /></a>
</a>
</center></p>
<p>After this, you should enable the <code>Snapping Toolbar</code> by checking <code>View -&gt; Toolbars -&gt; Snapping Toolbar</code>, which enables you to connect endpoints of lines. This gives you the button highlighted in the figure below:</p>
<p><center>
<a name = "SnappingTool">
    <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/SnappingTool.png"><img alt="SnappingTool" src="../img/Snapping_Tool.png" /></a>
</a>
</center></p>
<!--- TODO: geh√∂rt der Punkt nach strg+ wirklich da hin? --->

<p>To insert additional lines you can use <code>Strg+.</code> or click the <code>Add Line Feature button</code> in the <em>toolbar</em>. Then you can insert lines by left-clicking and ending a line segment by right-clicking. This enables you to create arbitrary graphs or to modify existing
line layers.</p>
<h4 id="graphbuilder-create-a-grid-graph">Create a Grid Graph</h4>
<p>A grid graph is a graph in which every vertex is connected to its four neighbouring vertices and the distance between every pair of connected vertices is the same. You can create such a graph by first selecting the <code>Create Grid tool</code> from the <em>Processing Toolbox</em>. This opens the window shown in the following figure:</p>
<p><center>
<a name = "CreateGridWindow">
    <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/Create_Grid_Window.png" target="blank"><img alt="CreateGridWindow" src="../img/Create_Grid_Window.png" /></a>
</a>
</center></p>
<p>You can see that the selected CRS in this window is <code>EPSG:3857</code>. You should choose this or another CRS that uses meters as its metric if you wish to select the horizontal and vertical spacing in meters or kilometers. Select <code>Point</code> as <em>grid type</em>, enter the desired spacing and choose an extend for the grid. Make sure that the extend and the spacing match correctly. Use this point set as input for the vector layer and choose <code>DistanceNN</code> as <em>connection type</em>. You have to enter the selected spacing and add a small number as the distance because the distance is exclusive.</p>
<h2 id="graphbuilder-additional-connection-parameters">Additional Connection Parameters</h2>
<p>There are two additional connection parameters in area 5. Both of them are optional parameters that offer the opportunity to give additional information to modify the initial graph created with all the other parameters. </p>
<p>First, it's possible to set <em>Forbidden areas</em>. You have to specify these areas as a polygon layer. All the edges crossing a bound of at least one of the polygons get deleted. This means that the resulting graph has no edges crossing these polygons. </p>
<p>The second option is called <em>Additional point layer</em>. You can give additional points which you want to insert into the graph if you selected a line layer as basis for your graph. This way you can define some additional points of interest which were not included in the original line layer. A newly inserted point is connected to the graph by creating one edge to the nearest vertex already contained in the graph. </p>
<h2 id="graphbuilder-distance-strategy">Distance Strategy</h2>
<p>Through the distance strategy, you can define the calculation of the edge costs. You can choose from 4 basic distances or you can choose to apply an <a href="#graphbuilder-Advanced-Distance-Strategy">advanced distance strategy</a>. The 4 basic strategies are <code>euclidean</code>, <code>manhattan</code>, <code>geodesic</code> and <code>ellipsiodal</code>. You can see the formulas for the distance calculation between two points <script type="math/tex">x_1,y_1</script> and <script type="math/tex">x_2,y_2</script> below. The formula <code>euclidean</code> defines the euclidean distance, <code>manhattan</code> the manhattan distance and <code>geodesic</code> 
the geodesic distance. </p>
<p><strong>Euclidean:</strong>
<script type="math/tex; mode=display">d_{eucl} = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}</script>
<strong>Manhattan:</strong>
<script type="math/tex; mode=display">d_{man} = |x_1 - x_2| + |y_1 - y_2|</script>
<strong>Geodesic:</strong>
<script type="math/tex; mode=display">d_{geo} = 2 \cdot 6371000 \cdot arcsin(\sqrt{sin^2(\frac{x_2 - x_1}{2}) + cos(x_1) cos(x_2) sin^2(\frac{y_2 - y_1}{2})})</script>
</p>
<p>Note that the geodesic distance is only applicable for a geographic CRS as it uses a sphere and is calculated by the <em>Haversine Formula</em>.</p>
<p>The formula for the ellipsoidal distance is not listed because this distance is calculated by QGIS and is different for every CRS. QGIS however, does not support the calculation of this distance for all CRS. So it's possible that the use of this formula leads to not calculated distances for some CRS.</p>
<h2 id="graphbuilder-advanced-distance-strategy">Advanced Distance Strategy</h2>
<p>This option enables you to define your own custom cost function by submitting a formula. This cost function formula has to be in line with our specific syntax. After you specified the formula, it is translated into numbers for the edge costs. This enables you to freely specify a variety of cost functions and model real world scenarios. This section will explain all of the expressions you can use and the syntax/restrictions of our modeling language.</p>
<p>If you select <code>Advanced</code> as distance strategy, new fields appear. You can see these fields in the figure below. In the first two lines you can provide any number of raster or respectively polygon layers. These layers can later be used in the specification of the cost function formula.</p>
<p><center>
<a name = "AdvancedParameters">
    <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/Plugin_CreateGraph.png" target="_blank"><img alt="AdvancedParameters" src="../img/Advanced_Parameters.png" /></a>
</a>
</center></p>
<p>In the <code>Advanced cost function</code> text field you can insert the formula for the cost function. This can directly be inserted into its corresponding field or you can click the <code>edit</code> button next to the field to open a widget, which makes the creation process easier by showing all available expressions. You can see this widget in the image below:</p>
<p><center>
<a name = "AdvancedWigdet">
    <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/Advanced_Widget.png" target="_blank"><img alt="AdvancedWigdet" src="../img/Advanced_Widget.png" /></a>
</a>
</center></p>
<p>In this widget you can insert the formula into the text field on the left. In the middle there is a tree view which shows all the available expressions you can use to build your cost function. The field on the right shows additional information about a selected expression. You can insert an expression by double-clicking it. This already gives you an idea of the syntax associated with an expression. </p>
<p>The next paragraphs show and explain all of the expressions and operators. Note that the complete formula is case sensitive.</p>
<h4 id="graphbuilder-operators">Operators</h4>
<p>You can use <script type="math/tex">{+, -, *, /}</script> as operators in the formula to add, subtract, multiply or divide expressions and variables. You can also use round brackets to structure your formula and insert spaces freely.</p>
<h4 id="graphbuilder-math">Math</h4>
<p>You can access all of the available math operators in the tree view. Just insert <code>math.</code> followed by the
desired math operator and set the parameters needed in round brackets. Note that only math operators with one or two parameters are supported. If the math expression requires two parameters separate them with a comma.</p>
<h4 id="graphbuilder-normal-distances">Normal Distances</h4>
<p>You can insert the four basic distances into the formula by simply typing <code>euclidean</code>, <code>manhattan</code>, <code>geodesic</code> or <code>ellipsoidal</code>. You can also use shortest path distances in connection with a raster layer, which are described in the paragraph about <a href="#graphbuilder-Raster-Analysis">raster analysis expressions</a>.</p>
<h4 id="graphbuilder-vector-layer-fields">Vector layer fields</h4>
<p>You can select all the field information of the underlying vector layer which contain numbers. To insert these numbers into the formula, just insert <code>field:</code> followed by the field name. If the underlying vector layer contains lines, the number is assigned directly to the appropriate edge in the graph. You can also use field information if you use a point layer as input. In this case, an edge is appointed the field information of the edge endpoint. </p>
<h4 id="graphbuilder-random">Random</h4>
<p>The <em>random expression</em> allows you to introduce randomness into the cost function. The syntax looks like <code>random(LB,UB)</code>, where <em>LB</em> is the lower bound and <em>UB</em> is the upper bound. Both bounds are inclusive. For example, if you insert <code>random(1,100)</code>, this results in random edge costs between 1 and 100. If at least one of the bounds is a floating point number, the resulting edge weights will be floating point numbers as well.</p>
<h4 id="graphbuilder-raster-analysis">Raster Analysis</h4>
<p>There are a lot of different ways to use raster layers in the cost function definition. To address a specific raster layer you selected before, enter <code>raster[index]</code>. Note that you can only access a raster layer that you inserted into the field you can see in the image on <a href="#graphbuilder-AdvancedParameters">Advanced Parameters</a> above. For example, to access the second raster layer you selected, enter <code>raster[1]</code>. After that, you can select an analysis type for the raster layer. </p>
<p>In the corresponding image <a href="#graphbuilder-createGraph">above</a>, you can see all the analysis options in the tree view of the Cost Function Window. The type names are self-explanatory. Nevertheless, you can see a short description in the <em>Cost Function Window</em> if you select an analysis. Before you enter the analysis type, enter a <code>:</code>, for example <code>raster[0]:sum</code> which adds up all the pixel values. </p>
<p>As you can see in the tree view of the <em>Cost Function Builder Widget</em>, every analysis is listed with and without a <code>sp</code> prefix. If you do not include this prefix, all pixel values an edge is crossing are included. </p>
<p>You can see a visualisation of the included pixels for one edge in the image below:</p>
<p><center>
<a name = "PixelsCrossed">
    <a :target="_blank" _="," href="https://project2.informatik.uni-osnabrueck.de/spanners/img/Pixels_Crossed.png" style="height:400px"><img alt="PixelsCrossed" src="../img/Pixels_Crossed.png" /></a>
</a>
</center></p>
<p>If you insert the prefix, a shortest path algorithm is executed to find the cheapest path through the pixels. 
The algorithm is started for every edge with the edges' two endpoints. All pixel values of this shortest path are included. You can create a visualisation of all the shortest paths by checking the <code>Show Shortest Path View</code> checkbox located in area 5 under the text field for the formula which appears if you insert a shortest path expression at some point. </p>
<p>You can see such a visualisation below:</p>
<p><center>
<a name = "ShortestPath">
    [<img alt="ShortestPath" src="../img/Shortest_Path_View.png" />](https://project2.informatik.uni-osnabrueck.de/spanners/img/Shortest_Path_View.png{: style="height:450px", :target="_blank"}
</a>
</center></p>
<p>All pixels that were visited by the algorithm are white. All pixels that the algorithm did not visit are black. The shortest paths are marked in different colours. To use a raster analysis in connection with the shortest path, you have to specify an heuristic index between 0 and 5. You can do this by inserting it in round brackets after the analysis type. For example, you could enter <code>raster[0]:spMean(3)</code> to execute the shortest path analysis on the first raster layer and a heuristic index of 3. This would result in a mean value of all the pixels on this shortest path. </p>
<p>It's important to know that the shortest path is only guaranteed to be exact if the heuristic index is set to 0. There exists a trade-off between the accuracy of the shortest path and the execution time. Basically, if you increase the index, the execution time gets smaller and the result gets more inaccurate. </p>
<p>There are four special cases of raster analysis which are described in the paragraph about <a href="#graphbuilder-if-Condition">if conditions</a>, because they can only be used in an if condition. You can also get information about the distance of the shortest path by inserting the \texttt{sp} prefix in front of one of the distance metrics. For example, <code>raster[0]:spEuclidean(0)</code> calculates the euclidean distance of the shortest paths with a heuristic index of 0. Note that this distance can only be as accurate as the resolution of the raster layer and that the calculation assumes that the pixel height and width are identical. It will lead to inaccurate results if this is not the case.</p>
<h4 id="graphbuilder-if-condition">if Condition</h4>
<p>You can use the <code>if</code> expression in order to test whether a specified condition is true or not and to change the cost function
accordingly. <br />The syntax you need to use looks like this: <code>if(condition; result_{true}; result_{false})</code>. </p>
<p>The condition has to be some kind of check, like <code>10 &lt; 20</code>. You can also combine conditions, like <code>10 &lt; 20 and 20 &lt; 30</code>. As comparison operators you can use <code>&lt;,&gt;,&lt;=,&gt;=,!=,==</code> and as connections between conditions you can use <code>and, or</code>. After the first semicolon, you can specify what the <code>if</code> expression should translate to if the condition is true and after the second semicolon, you can define what it should translate to if the condition is false. </p>
<p>An example for a complete if expression is <code>if(euclidean &lt; 100; 10; 20)</code>. In this example the weight of an edge is set to 10 if the euclidean distance between the end points is less than 100 and to 20 if not. </p>
<p>There are a total of 6 expressions that can only be used in the condition of an if expression. The first two refer to polygon layers you can specify in the field you can see in the image on <a href="#graphbuilder-AdvancedParameters">AdvancedParameters</a>. You have the possibility to test whether an edge crosses a polygon of a specific polygon layer or to test whether it lies inside one. To identify the polygon layer you wish to use, enter <code>polygon[index]</code> with index referring to the place the layer was inserted. For example, <code>polygon[2]</code> refers to the third polygon layer you inserted in the field. After that, you have to type a <code>:</code> followed by either <code>crossesPolygon</code> or <code>insidePolygon</code>. This polygon expression will be translated to <code>true</code> or <code>false</code>. For example, you can insert the formula 
<code>if(polygon[0]:crossesPolygon == True; 10; 20)</code> to set all the edges crossing a polygon of the first inserted polygon layer to 10 and all other edges to 20.</p>
<p>The other 4 expressions refer to raster layers. First you have to specify the raster layer. After that, insert again a <code>:</code>, followed by <code>pixelValue</code> or <code>percentOfValues</code>. Similar to the shortest path options described in the previous paragraph, you can use the <code>sp</code> prefix to use the shortest path pixel values instead of the pixels which are crossed by the edge. You can use <code>pixelValue</code> to test if at least one of the pixel values fulfills the condition. For example, the condition <code>raster[0]:pixelValue == 100</code> checks if at least one pixel value is equal to 100. If you use the <code>sp</code> prefix, you have to give the heuristic index in round brackets again. Use <code>percentOfValues</code> to test if a specified percentage of the pixel values satisfy the condition. You can declare this percentage in round brackets. For example, the condition <code>raster[0]:percentOfValues(50) &gt; 100</code> tests whether 50 percent or more of the pixel values are greater then 100. If you use the <code>sp</code> prefix, you have to specify two values in the round brackets, separated by a comma: first the heuristic index for the shortest path algorithm and second the percentage. For example, <code>raster[0]:spPercentOfValues(3,50) &gt; 100</code>, with 3 being the heuristic index and 50 being the percentage. </p>
<p>All the examples above are very simple expressions. You can also combine all the expressions to form more complex ones. Examples for that are listed below. Note that you can nest all the expressions freely as long as you don't nest the same expression. So for example it's not possible to create a formula <code>random(random(10,20),100)</code>. Another limitation exists due to the fact that you can not negate any variable, since there has to be a variable on each side of an operator. So for example <code>-euclidean</code> is not possible.
As a workaround you can use <code>0-euclidean</code>.</p>
<p>In the following, a list of examples is given, starting from very simple ones to more complex examples. An explanation is provided for every formula as well. Not all of the formulas make sense to use. The examples should only outline the basic capabilities of the system.</p>
<table>
<thead>
<tr>
<th>if Condition</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>42</code></td>
<td>Constant cost of 42 for every edge</td>
</tr>
<tr>
<td><code>math.pow(10, 2)</code></td>
<td>Evaluates to <script type="math/tex">10^2 = 100</script>
</td>
</tr>
<tr>
<td><code>field:maxspeed * euclidean</code></td>
<td>Accesses the maximum speed information of a line layer</td>
</tr>
<tr>
<td><code>math.ceil(manhattan * random(0.1, 1.5))</code></td>
<td>Uses the ceil function to round up the value in the <br />brackets. For the calculation of the value, multiply <br /> the manhattan distance with a random floating point <br /> value between 0.1 and 1.5</td>
</tr>
<tr>
<td><code>if(raster[0]:spEuclidean(0) &lt; 3*euclidean;raster[0]:spSum(0);raster[0]:sum)</code></td>
<td>Sets the cost of an edge to the sum of the raster pixels <br /> of the shortest path if the euclidean distance of the <br /> shortest path is not 3 times longer then the <br />direct euclidean distance. If the shortest path is <br />too long then the cost is set to the normal sum <br />of the pixel values</td>
</tr>
<tr>
<td><code>if(raster[0]:spEuclidean(0) &lt; random(1,5) * euclidean; math.cos(raster[0]:spSum(0) + random(euclidean, manhattan)); math.sqrt(raster[0]:sum))</code></td>
<td>Similar to the previous example, but some embedded <br /> random and math functions</td>
</tr>
<tr>
<td><code>random(if(polygon[0]:crossesPolygon == True; euclidean; manhattan), if(polygon[0]:insidePolygon == True ;euclidean*2;manhattan*2))</code></td>
<td>Calculates a random value. The upper and lower bound <br />are dependant on the evaluation of two if expressions<br /> which use polygon expressions in their conditions</td>
</tr>
</tbody>
</table>
<p>To make it easier for you to specify the formula, a check is performed constantly as you type in your cost function. You can see the result of this syntax check below the text field for the cost function in the <em>Cost Function Window</em>. Additionally to a brief description of the problem, the part where the problem is located is highlighted as well. </p>
<p>Unfortunately, the coverage of this syntax check is not at 100 percent, so there are some cases where the syntax check is not able to recognise the mistake in the formula. This problem occurs mainly with simple typing errors, which should always be easy to correct if the graph creation process should fail/terminate.</p></section><section class="print-page" id="graphlayer"><h1 id="graphlayer-the-graph-layer">The Graph Layer</h1>
<p>The graph layer allows you to visualize the graph you created using the <a href="#graphbuilder">Graph Builder</a>. Several options are given to help increasing the <a href="#graphlayer-visualization-options">visibility of the graph</a>. In addition to that, the <em>Graph layer window</em> enables you to <a href="#graphlayer-graph-editing">edit the graph</a> after creating it. The graph and your adjustments on it can be saved to your QGIS-Project or you can <a href="#graphlayer-graph-export">export</a> it to a <a href="https://qgis.org/pyqgis/master/core/QgsVectorLayer.html"><code>QgsVectorLayer</code></a> (which is simply called <em>vector layer</em> in the following) or to a vector file. <!--alte Version: The graph and your adjustments on it can be saved to your QGIS-Project or you can <a href="#graphlayer-graph-export">export</a> it to a vector layer or vector file.--><br />
Note that the graph layer is based on a <a href="https://qgis.org/pyqgis/master/core/QgsPluginLayer.html"><code>QgsPluginLayer</code></a> so it does provide its own functionality independent from possibly existing operations for a vector layer. The <em>Graph layer window</em> contains some basic information about your created graph in addition to an UI. It can be opened by double-clicking the layer in the <em>layer browser</em>. Note that this window replaces the default properties window of e.g. a vector layer. This is the <em>Graph layer window</em>:</p>
<p><center>
    <a name = "GraphLayerWindow">
        <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/graph_layer_window.png" target="_blank"><img alt="The graph layer window" src="../img/graph_layer_window.png" /></a>
    </a>
</center></p>
<h2 id="graphlayer-graph-information">Graph Information</h2>
<p>The <em>Graph layer window</em> shows all relevant information of your graph or graph layer in one place. This information consists of name, vertex count, edge count, coordinate reference system and all settings done by the graph builder. The last mentioned data can be useful when working with random graphs especially if you want to edit them by hand after creating them initially.</p>
<h2 id="graphlayer-visualization-options">Visualization Options</h2>
<p>Directly below the general information, the <em>Graph layer window</em> consists of several buttons to toggle some visual properties of the graph. <!-- ich hab den Satz auch nur √ºbernommen und er ergibt mit dem after nicht so Sinn f√ºr mich, ist das mit dem below okay?--></p>
<h4 id="graphlayer-zoom-to-layer">Zoom to Layer</h4>
<p>The canvas included in a QGIS window allows you not only to see your added layer but also to move it around, zoom in and zoom out. This button resets the canvas to include the whole graph.</p>
<h4 id="graphlayer-toggle-rendering">Toggle Rendering</h4>
<p>This button toggles the complete rendering process of the graph, making it invisible if disabled. This operation is very similar to the <code>visibility</code> checkbox in the layer browser which also disables or enables the rendering of a layer.</p>
<h4 id="graphlayer-toggle-lines">Toggle Lines</h4>
<p>Depending on the density of your graph, a lot of edges may be overlapping and eventually resulting in an unclear graph picture. This button toggles the visibility of all edges/lines. For very large graphs this might improve the renderer's performance.</p>
<h4 id="graphlayer-toggle-edge-text">Toggle Edge Text</h4>
<p>If the graph's edges are visible, this button toggles the visibility of the attached edge costs.</p>
<h4 id="graphlayer-toggle-direction">Toggle Direction</h4>
<p>If the graph's edges are visible, this button toggles the visibility of the edge directions. Represented by red arrow heads, the edge direction can be of help for the graph editing described in the <a href="#graphlayer-graph-editing">next section</a>.</p>
<h4 id="graphlayer-choose-cost-function">Choose Cost Function</h4>
<p>As shown in the section regarding <a href="#graphbuilder-advanced-distance-strategy">advanced distances</a>, you can add multiple <em>advanced costs</em> to your graph and its edges. As mentioned before, only one edge text and therefore only one edge cost is visually attached to a line in the rendered layer. To select a specific edge cost to be shown on the canvas, you can select the corresponding cost function index with the number field in the <em>Graph layer window</em>. Note that, in contrast to the toggle buttons, after selecting a cost function index, the canvas will not update itself. By using one of the already explained buttons or slightly moving the canvas you can update the graph layer and see the correct edge costs. On the other hand, if pressed, the <code>Next</code> button will set the cost function automatically to the next available one.</p>
<h4 id="graphlayer-random-vertex-color">Random Vertex Color</h4>
<p>Each time a graph is rendered, a new random vertex color will be chosen. To make sure a highly visible color is chosen or to distinguish several rendered graphs from each other, this button randomizes the vertex color.</p>
<h2 id="graphlayer-graph-editing">Graph Editing</h2>
<p>After creating and checking the graph for correctness, you can edit your graph with the graph layers own <em>Edit Mode</em>. <code>Toggle Editing</code> activates or deactivates the edit mode which enables you to adjust your graph directly on the canvas.</p>
<h3 id="graphlayer-edit-operations">Edit Operations</h3>
<p>Using a combination of mouse and keyboard inputs, the provided options are:</p>
<ul>
<li>
<p><strong>Right-click</strong> on a vertex to select it. If clicked on, a selected vertex will be marked with a red cross. To deselect the vertex again, right-click somewhere else on the canvas NOT hitting another vertex.</p>
</li>
<li>
<p><strong>Right-click a second vertex</strong> first checks if an edge exists from your first selected vertex to the second selected vertex. If such an edge exist, an edge window (see below) will be opened, giving you more information on the selected edge and allowing you to modify it further.</p>
<p><center>
    <a name = "GraphLayerEdgeWindow">
        <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/graph_layer_edge_window.png" target="_blank"><img alt="Graph Layer Edge Window" src="../img/graph_layer_edge_window.png" /></a>
    </a>
</center></p>
<p>To select an edge, the <code>Toggle Direction</code> operation might be useful, since the edge selection is direction specific.<br />
If the two selected vertices do not define an edge, a new edge will be added to the graph. Here, the edge window will also be shown to allow you to directly see its information or modify it further:</p>
<ul>
<li>If the graph is created with <em>advanced edge cost functions</em>, the edge window will show a number field for each cost function, allowing you to check and modify their contents. Clicking on <code>Apply</code> will apply your changes to the edge costs.</li>
<li><code>Toggle Highlight</code> will highlight or normalize the selected edge visually. A highlighted edge will be rendered as a thick red line.</li>
<li><code>Delete</code> will delete the selected edge.</li>
</ul>
</li>
</ul>
<!-- ich w√ºrde right-click und left click und hold dann evtl eher klein schreiben, oder? Und was ist mit den Anf√§ngen eines Stichpunktes? Dann das doch gro√ü lassen?-->
<ul>
<li>
<p><strong><code>CTRL</code> + right-click</strong> on a selected vertex will delete this vertex with all its attached edges.</p>
</li>
<li>
<p><strong>left-click</strong> will add a new vertex to the graph on the clicked position.</p>
</li>
<li>
<p><strong>Selected vertex + left-click</strong> will move the selected vertex to the clicked position instead of creating a new one. Note that the edge costs are calculated dynamically. That means moving a vertex to a different position will change the edge costs of its incident edges. Also note that this option is disabled for <em>advanced edge costs</em> as they cannot be calculated dynamically.</p>
</li>
<li>
<p><strong><code>CTRL</code> + left-click</strong> will add a new vertex to the clicked position with edges according to the originally chosen settings in the <a href="#graphbuilder-random-graph">random graph</a><!--f√§llt dir eine sch√∂nere Formulierung f√ºr die Referenzierung ein?-->. E.g. if the original graph was created with <em>Nearest Neighbor</em>, <em>Euclidean Distance</em> and two neighbours, the newly added vertex will also be connected to its two nearest neighbours. Note that this option is disabled for graphs with <em>advanced edge costs</em> similar to the option above.</p>
</li>
<li>
<p><strong>Hold <code>SHIFT</code> + left-click</strong> allows you to select multiple vertices by a rectangle. After releasing the left-click (still holding <code>SHIFT</code>), all vertices will be marked with a red cross and a vertices window will be opened:</p>
<p><center>
    <a name="GraphLayerVerticesWindow">
        <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/graph_layer_vertices_window.png" target="_blank"><img alt="" src="../img/graph_layer_vertices_window.png" /></a>
    </a>
</center></p>
<ul>
<li><code>Show/Hide Vertex IDs</code> will show or hide the IDs of the selected vertices. <!-- ich w√ºrde hier nochmal nachfragen ob das entweder immer hide hei√üt oder der Punkt "show/hide" hei√üen sollte, oder? Im Bild hei√üt es zumindest hide--></li>
<li><code>Delete Vertices</code> will delete all selected vertices.</li>
<li><code>Delete Edges</code> will delete all edges attached to the selected vertices.</li>
</ul>
</li>
<li>
<p><strong><code>Undo/Redo</code></strong> buttons on the bottom of the <em>Graph layer window</em> will keep track of all your executed edit operations on your graph. This includes adding/deleting vertices and edges, moving a vertex or setting new costs to an edge. This operations can be undone or redone by the respective buttons. Note that deleting a vertex with attached edges will lead to an undo operation containing not only the vertex but also all previous attached edges. The same applies to the deletion of multiple selected vertices or edges. After undoing an operation and then executing another one the operation which was undone previously will be lost.</p>
</li>
<li>
<p><strong>Exiting Edit Mode</strong> When in editing mode, pressing <code>ESC</code> will return you to the usual tool for moving the canvas instead of editing the graph.</p>
</li>
</ul>
<h3 id="graphlayer-graph-export">Graph Export</h3>
<p>After adjusting your graph, you can export it via the <em>Graph layer window</em>. <code>Export to VectorLayer</code> will create two <code>VectorLayer</code>s and add them to the project making them appear in the layer browser. Since <code>VectorLayer</code>s can only represent either lines or points, two layers will be created. One for each geometry to include all aspects of your graph. Note that an added vertex not attached to the graph by any edge will not appear in the <code>line vector layer</code>. The <code>Export To File</code> button works very similar. Instead of creating vector layers you can choose between <code>.shp</code>, <code>.gpkg</code>, <code>.csv</code>, <code>.geojson</code> and <code>.graphml</code> in a file browser when choosing a place to store the new files. The first four data-types are vector types and can therefore only store one type of geometry similar to a <code>VectorLayer</code>. In the <em>Graph layer window</em> <!-- habe es jetzt √ºberall so geschrieben (in den Bildern steht das auch mit Gro√ü- und Kleinbuchstaben gemischt)--> you can also choose which geometry type should be exported. The <em>Export Types</em> are <code>Only Points</code>, <code>Only Lines</code> and <code>Both</code>.</p>
<p>In addition to layer and file export, it is possible to store your graph in a QGIS-Project. A project will keep track of all your layers in the layer browser if you save them as a <code>.qgs</code> or <code>.qgz</code> project. When loaded, the plugin can also retrieve all graph information to the layers, making it unnecessary to create your graphs again in each new session.</p></section><h1 class='nav-section-title-end'>Ended: Beginner's Guide</h1>
                        <h1 class='nav-section-title' id='section-advanced-applications'>
                            Advanced Applications <a class='headerlink' href='#section-advanced-applications' title='Permanent link'>‚Üµ</a>
                        </h1>
                        <section class="print-page" id="handlers"><h1 id="handlers-generating-your-own-handlers">Generating Your Own Handlers</h1>
<p>To execute a graph algorithm on the server, the algorithm needs to be implemented as a so-called <em>handler</em>. The backend library provides a C++ interface to easily add <em>generic handlers</em>. The following section describes the steps needed to implement a new generic handler and provides an example.</p>
<p>Handlers added the way described here are automatically detected by the S.P.A.N.N.E.R.S.-Plugin upon first connection to a server and can directly be used.</p>
<p>The general steps needed to build a generic handler are the following:</p>
<ol>
<li>Create a C++ file for the handler (<code>.hpp</code> and, if needed, <code>.cpp</code>) and add it to the <code>CMakeLists.txt</code></li>
<li>Create a class for the handler</li>
<li>Inherit from <code>abstract_handler.hpp</code></li>
<li>Implement the static <code>name()</code> function</li>
<li>Implement the static <code>handler_information()</code> function</li>
<li>Provide a constructor</li>
<li>Implement the <code>handle()</code> function</li>
<li>Register the handler in <code>register_handlers.cpp</code></li>
<li>Recompile the server</li>
</ol>
<h2 id="handlers-general-steps-in-building-a-handler">General Steps in Building a Handler</h2>
<h3 id="handlers-creating-the-files">Creating the Files</h3>
<p>The first step in building a handler is to create matching C++ files. Those are a header (<code>.hpp</code>) and, if needed, a source file (<code>.cpp</code>). By default, handler files can be found in <code>include/handling/handlers</code> and <code>src/handling/handlers</code>. To add the files to the compilation unit, they must be added to their respective lists <code>SERVER_HEADER</code> and <code>SERVER_SOURCES</code> in <code>src/CMakeLists.txt</code>.</p>
<h3 id="handlers-creating-a-class-and-inheritance">Creating a Class and Inheritance</h3>
<!--purely statt pure??-->
<p>During runtime, handlers are objects which are created separately for each request. Every handler is implemented as a class and such a handler class must inherit from the pure virtual class <code>abstract_handler.hpp</code>.</p>
<h3 id="handlers-implement-name">Implement <code>name()</code></h3>
<p>A function with the signature <code>static std::string name()</code> must be implemented. This function should output a unique name for the handler. This will be the name shown to the user in the frontend. As explained in <a href="#handlers-register-the-handler">a later section</a>, it is discouraged to use <code>/</code> as a character in this name.</p>
<h3 id="handlers-implement-handler_information">Implement <code>handler_information()</code></h3>
<p>A handler must provide the client with information about which data is needed to process a request and information about which data will be part of the resulting response. The function <code>static graphs::HandlerInformation handler_information()</code> creates a so-called <em>handler information object</em>. This object consists of fields that indicate which data is needed and which data is part of the answer. In the <code>handler_information()</code> function, the information object is created with a call to <code>createHandlerInformation()</code>. For a generic handler, the arguments must always be <code>name()</code> and <code>graphs::RequestType::GENERIC</code>.</p>
<p>Every information that is needed to process a request (including the graph itself) must be set with the <code>addFieldInformation()</code> function. Its first argument is always the handler information object itself. The second argument specifies the type of the field. This might be the graph itself, information associated with nodes and edges or singular values. A list of possible types can be found in the table below or in the protocol file <code>available_handlers.proto</code> under <code>FieldInformation</code>.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BOOL</code>, <code>DOUBLE</code>, <code>CHOICE</code>, <code>INT</code>, <code>LITERAL</code>, <code>STRING</code></td>
<td>Sets a single entry of the type.</td>
</tr>
<tr>
<td><code>GRAPH</code></td>
<td>Activates the graph entry.</td>
</tr>
<tr>
<td><code>EDGE_COST</code>, <code>VERTEX_COST</code></td>
<td>Sets a weight for each edge or node</td>
</tr>
<tr>
<td><code>EDGE_ID</code>, <code>VERTEX_ID</code></td>
<td>Sets a single entry which must be an edge <br /> or node index.</td>
</tr>
<tr>
<td><code>EDGE_ID_ARRAY</code>, <code>VERTEX_ID_ARRAY</code></td>
<td>Sets an array of edge or node indices.</td>
</tr>
<tr>
<td><code>VERTEX_COORDINATES</code></td>
<td>Activates vertex coordinates.</td>
</tr>
</tbody>
</table>
<p>The third argument given to <code>addFieldInformation()</code> is the name of the field displayed in the frontend, the fourth is the unique internal key of the field. Keys that are not for the graph, node coordinates or edge and node weights must start with <code>graphAttributes.*</code>. The last argument indicates whether this field is required or optional for a request. If omitted, the field is optional by default.</p>
<p>The syntax to add to response fields is nearly identical, in this case the function <code>addResultInformation()</code> is called. Its first argument is, again, the handler information object, its second argument is the type, fourth and fifth are unique name and display name.</p>
<h3 id="handlers-constructor">Constructor</h3>
<p>The handler must provide a constructor which takes an <code>std::unique_ptr&lt;abstract_request&gt;</code> as its only argument. This will provide the handler with the request it must answer. The request itself will be processed in the <code>handle</code> function later. In the constructor, the handler can check whether the request is a correct request for the handler and apply preprocessing as needed.</p>
<h3 id="handlers-implement-handle">Implement <code>handle()</code></h3>
<p>The function <code>std::pair&lt;graphs::ResponseContainer, long&gt; handle()</code> is called by the server to process the request. It overrides the equivalent pure virtual function of <code>abstract_handler</code>. This function has the purpose to extract the information from the request, call the graph algorithm and then build the response object.</p>
<p>The request consists of a <code>graph_message</code>, which stores the structural information of the graph and of the fields previously set with <code>handler_information()</code>. The <code>graph_message</code> object is immutable and allows access to the graph and gives an index-based view on this graph. The fields in the <code>generic_request</code> are accessed through member functions. Some attributes like node coordinates or weights have specialized functions to allow direct access, others must be accessed through attribute maps. A more in-depth list of access functions is provided via the code documentation.</p>
<p>The return type of <code>handle()</code> is a pair of the response in the form of a <code>graphs::ResponseContainer</code> and a <code>long</code> integer. This integer should represent the time in microseconds the graph algorithm itself needed. The <code>graphs::ResponseContainer</code> is made by the function <code>response_factory::build_response</code>, which takes a <code>generic_response</code>. A <code>generic_response</code> follows the same logic as a <code>generic_request</code>, it contains a <code>graph_message</code> and attributes as arrays and maps.</p>
<h3 id="handlers-register-the-handler">Register the Handler</h3>
<p>A handler first needs to be registered so that the server is able to recognize it. This is done in the file <code>src/handling/register_handlers.cpp</code>. Here, the header of the handler file must be included and the class must be registered in the function <code>init_handlers()</code>. For this, the function <code>register_handler()</code> is called with the handler class as template argument.</p>
<p>One optional string can be given to <code>register_handler()</code> as argument. This string is interpreted as a directory structure, where every <code>/</code> signals a new subdirectory.  In this way, handlers can be sorted in categories to be displayed in the frontend. This also applies to every <code>/</code> set in the <code>name()</code> function.</p>
<h3 id="handlers-recompile-the-server">Recompile the Server</h3>
<p>Lastly, for the new handler to be active, the server must be recompiled and restarted.</p>
<h2 id="handlers-example-kruskal-mst-handler">Example: Kruskal MST Handler</h2>
<p>This section will describe how to add a simple handler for Kruskal's minimum spanning tree algorithm.</p>
<p>The first step is to create <code>include/handling/handlers/kruskal_handler.hpp</code> and <code>src/handling/handlers/kruskal_handler.cpp</code> and add them to <code>src/CMakeLists.txt</code>:</p>
<!-- nochmal √ºberlegen, ob man das im Codeblock oder in einem Bild einf√ºgt-->

<pre><code>set(SERVER_HEADERS
    ${CMAKE_SOURCE_DIR}/include/handling/handler_factory.hpp
</code></pre>
<p><center>
<a name = "cmake1">
    <img alt="ShortestPath" src="../img/cmake1.png" />
</a>
</center></p>
<p>...</p>
<p><center>
<a name = "cmake2">
    <img alt="ShortestPath" src="../img/cmake2.png" />
</a>
</center></p>
<p>Next, we declare the class <code>kruskal_handler</code> in <code>include/handling/handlers/kruskal_handler.hpp</code> as follows:</p>
<p><center>
<a name = "class">
    <img alt="ShortestPath" src="../img/class.png" />
</a>
</center></p>
<p>The class inherits from <code>abstract_handler</code> and implements all functions needed for a handler. The private attribute <code>m_request</code> stores the request given to the constructor for later access.</p>
<p>Now, the functions need to be defined in <code>src/handling/handlers/kruskal_handler.cpp</code>. The first function to implement is <code>name()</code>. </p>
<p><center>
<a name = "name">
    <img alt="ShortestPath" src="../img/name.png" />
</a>
</center></p>
<p>The next function should be <code>handler_information</code>. For Kruskal's algorithm, the algorithm only needs the graph itself and edge weights. To represent the solution later, the coordinates of the nodes are also required. The response should send back a tree in the form of a graph, the coordinates to draw the nodes in QGIS and the edge weights of the surviving edges. The resulting function should look like this:</p>
<p><center>
<a name = "handlerInfo">
    <img alt="ShortestPath" src="../img/handler_info.png" />
</a>
</center></p>
<p>The constructor takes an <code>abstract_request</code> and tries to cast it into a generic request.</p>
<pre><code>kruskal_handler::kruskal_handler(std::unique_ptr&lt;abstract_request&gt; request)
{
    if(const auto *type_check_ptr = dynamic_cast&lt;generic_request *&gt;(request.get());
    {
        throw server::request_parse_error("kruskal_handler: dynamic_cast failed!", request-&gt;type(), name());
    }
    m_request = std::unique_ptr&lt;generic_request&gt;{static_cast&lt;generic_request *&gt;(request.release())};
}
</code></pre>
<p><center>
<a name = "constructor">
    <img alt="ShortestPath" src="../img/constructor.png" />
</a>
</center></p>
<p>Now, the <code>handle()</code> function does several things. First, all information needs to be copied into a new graph (because the graph from the request is immutable and the algorithm cuts edges):</p>
<p><center>
<a name = "handle1">
    <img alt="ShortestPath" src="../img/handle1.png" />
</a>
</center></p>
<p>Then, the function <code>makeMinimumSpanningTree()</code> from the OGDF is called and its runtime is measured:</p>
<p><center>
<a name = "handle2">
    <img alt="ShortestPath" src="../img/handle2.png" />
</a>
</center></p>
<p>Finally, the result is packed into a response object:</p>
<p><center>
<a name = "handle3">
    <img alt="ShortestPath" src="../img/handle3.png" />
</a>
</center></p>
<p>The new handler must then be registered in the function <code>init_handlers()</code> in <code>src/handling/register_handlers.cpp</code>:</p>
<p><center>
<a name = "register">
    <img alt="ShortestPath" src="../img/register.png" />
</a>
</center></p>
<p>In the OGDF plugin, the new handler now appears under the category <em>Minimum Spanning Trees</em>.</p>
<p>The entire code of this example (and also some other example handlers) is implemented in the backend repository. The files can be found under <code>include/handling/handlers/kruskal_handler.hpp</code> and <code>src/handling/handlers/kruskal_handler.cpp</code>.</p>
<h2 id="handlers-specialized-handlers">Specialized Handlers</h2>
<p>It is also possible to create specialized handlers for complicated use cases not covered by generic handlers. This, however, would involve changing and expanding server, frontend and protocol code. It is out of the scope of this handbook to provide instructions on this, but the possibility should be noted here.</p></section><section class="print-page" id="testing"><h1 id="testing-testing-your-results">Testing Your Results</h1>
<p>The Benchmark System is represented as a tab in the user interface and gives you the possibility to execute experiments using the graphs you created. Through
multiple calls to the OGDF, you can compare an algorithm's performance on different graphs and compare several algorithms with each other. The system automatically does all the necessary calls and can also create plots, which can showcase the results. This is the UI of the system:</p>
<p><center>
    <a name="benchmarksystem">
        <a href="https://project2.informatik.uni-osnabrueck.de/spanners/img/Benchmark_System.png" target="_blank"><img alt="Benchmark System" src="../img/Benchmark_System.png" /></a>
    </a>
</center></p>
<p>In <span style="color:#e60000">area 1</span> you can select any number of graphs currently loaded in QGIS by double-clicking.<br />
<span style="color:red">Area 2</span> shows all the selected graphs. You can remove graphs from this selection by double-clicking the graph in the list. If you want to choose all graphs at once, you can also press the <code>green arrow</code>.  In the two areas below you can make all the required selections concerning the OGDF algorithms.<br />
All algorithms available are listed in <span style="color:#e60000">area 3</span> and can be selected directly.<br />
<span style="color:#e60000">Area 4</span> automatically shows all the appropriate parameters for the algorithms.
For every parameter, you can specify a range of values you wish to examine. Furthermore, it's possible to execute every graph with all of its cost functions. For every algorithm, you can define the number of executions, so you can have a look at the average and deviations of different executions with the same parameters.<br />
<span style="color:#e60000">Area 5 and 6</span> regard the visualisation of the results. If you want to create different visualisations/benchmarks of the results, you can press the <code>+</code> button, which creates two additional areas below.<br />
You can make three selections in <span style="color:#e60000">area 5</span>: First, two parameter selections have to be made.
The first selection is in connection with the colour-coded categorisation of the data. This means the original data set will be divided into multiple independent data sets and for each set a legend entry is created and the second selection defines the structuring of the x-axis. 
The third selection is the analysis, which defines the y-axis of the plot. Note that you can also make multiple selections for the parameters
or no selection for the first parameter. Naturally, the selectable parameters change with the algorithms you selected in <span style="color:#e60000">area 3</span>.
For example if you choose <code>Graph</code> and <code>Algorithm</code> for the first parameter selection, the resulting plot breaks down the results by graphs and algorithms. It shows a different colour for all the possible combinations of graphs and algorithms. Of course, it is possible that multiple values exist for one data point in the plot. In this case the system automatically calculates the average over all the values.
The last thing you need to do is to define the type of plot you wish to create in <span style="color:#e60000">area 6</span>, but you can also choose to create multiple plots for the same data.
In addition you can select some options regarding the design of the plot.</p>
<p>At the bottom of the tab you can specify a path to a folder. If you check the <code>Create .csv file</code> checkbox, multiple csv-files will be created and put into this folder. One of these files contains all the executions and values associated with the calls and one file is created for every benchmark visualisation you created, containing all the concrete numbers of the plot.  The name of the file containing all information starts with
<code>Complete\_Benchmark</code> and the filenames for the visualisations all start with <code>BenchmarkResult</code>. To differentiate the files, the file names end with the date and time of the creation.</p></section><h1 class='nav-section-title-end'>Ended: Advanced Applications</h1>
                        <h1 class='nav-section-title' id='section-about-the-s-p-a-n-n-e-r-s-plugin'>
                            About the S.P.A.N.N.E.R.S.-Plugin <a class='headerlink' href='#section-about-the-s-p-a-n-n-e-r-s-plugin' title='Permanent link'>‚Üµ</a>
                        </h1>
                        <section class="print-page" id="licenses"><h1 id="licenses-licences">Licences</h1>
<p>Work In Progress</p></section><section class="print-page" id="about"><h1 id="about-about-us">About us</h1>
<p>Work In Progress</p></section><h1 class='nav-section-title-end'>Ended: About the S.P.A.N.N.E.R.S.-Plugin</h1></div>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '/';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="/js/print-site.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="/search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(false);
        };
    </script>

</body>
</html>
