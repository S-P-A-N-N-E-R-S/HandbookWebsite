<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="canonical" href="https://example.com/handlers/">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Generating Your Own Handlers - S.P.A.N.N.E.R.S.-Plugin</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  <link href="../css/print-site.css" rel="stylesheet" />
  <link href="../extra.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Generating Your Own Handlers";
    var mkdocs_page_input_path = "handlers.md";
    var mkdocs_page_url = "/handlers/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> S.P.A.N.N.E.R.S.-Plugin</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Setup</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../docker/">Using Docker</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../git/">Using Git</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Beginner's Guide</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../ui/">User Interface</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../graphbuilder/">Graph Builder</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../graphlayer/">Graph Layer</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Advanced Applications</span></p>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Generating Your Own Handlers</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#general-steps-in-building-a-handler">General Steps in Building a Handler</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#creating-the-files">Creating the Files</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creating-a-class-and-inheritance">Creating a Class and Inheritance</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#implement-name">Implement name()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#implement-handler_information">Implement handler_information()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#constructor">Constructor</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#implement-handle">Implement handle()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#register-the-handler">Register the Handler</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#recompile-the-server">Recompile the Server</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#example-kruskal-mst-handler">Example: Kruskal MST Handler</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#specialized-handlers">Specialized Handlers</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../testing/">Testing Your Results</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">About the S.P.A.N.N.E.R.S.-Plugin</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../licenses/">Licenses</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../about/">About</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">S.P.A.N.N.E.R.S.-Plugin</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Advanced Applications &raquo;</li>
        
      
    
    <li>Generating Your Own Handlers</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
    <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
        <a href="../testing/" class="btn btn-neutral float-right" title="Testing Your Results">Next <span class="icon icon-circle-arrow-right"></span></a>
        <a href="../graphlayer/" class="btn btn-neutral" title="Graph Layer"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="generating-your-own-handlers">Generating Your Own Handlers</h1>
<p>To execute a graph algorithm on the server, the algorithm needs to be implemented as a so-called <em>handler</em>. The backend library provides a C++ interface to easily add <em>generic handlers</em>. The following section describes the steps needed to implement a new generic handler and provides an example.</p>
<p>Handlers added the way described here are automatically detected by the S.P.A.N.N.E.R.S.-Plugin upon first connection to a server and can directly be used.</p>
<p>The general steps needed to build a generic handler are the following:</p>
<ol>
<li>Create a C++ file for the handler (<code>.hpp</code> and, if needed, <code>.cpp</code>) and add it to the <code>CMakeLists.txt</code></li>
<li>Create a class for the handler</li>
<li>Inherit from <code>abstract_handler.hpp</code></li>
<li>Implement the static <code>name()</code> function</li>
<li>Implement the static <code>handler_information()</code> function</li>
<li>Provide a constructor</li>
<li>Implement the <code>handle()</code> function</li>
<li>Register the handler in <code>register_handlers.cpp</code></li>
<li>Recompile the server</li>
</ol>
<h2 id="general-steps-in-building-a-handler">General Steps in Building a Handler</h2>
<h3 id="creating-the-files">Creating the Files</h3>
<p>The first step in building a handler is to create matching C++ files. Those are a header (<code>.hpp</code>) and, if needed, a source file (<code>.cpp</code>). By default, handler files can be found in <code>include/handling/handlers</code> and <code>src/handling/handlers</code>. To add the files to the compilation unit, they must be added to their respective lists <code>SERVER_HEADER</code> and <code>SERVER_SOURCES</code> in <code>src/CMakeLists.txt</code>.</p>
<h3 id="creating-a-class-and-inheritance">Creating a Class and Inheritance</h3>
<!--purely statt pure??-->
<p>During runtime, handlers are objects which are created separately for each request. Every handler is implemented as a class and such a handler class must inherit from the pure virtual class <code>abstract_handler.hpp</code>.</p>
<h3 id="implement-name">Implement <code>name()</code></h3>
<p>A function with the signature <code>static std::string name()</code> must be implemented. This function should output a unique name for the handler. This will be the name shown to the user in the frontend. As explained in <a href="#register-the-handler">a later section</a>, it is discouraged to use <code>/</code> as a character in this name.</p>
<h3 id="implement-handler_information">Implement <code>handler_information()</code></h3>
<p>A handler must provide the client with information about which data is needed to process a request and information about which data will be part of the resulting response. The function <code>static graphs::HandlerInformation handler_information()</code> creates a so-called <em>handler information object</em>. This object consists of fields that indicate which data is needed and which data is part of the answer. In the <code>handler_information()</code> function, the information object is created with a call to <code>createHandlerInformation()</code>. For a generic handler, the arguments must always be <code>name()</code> and <code>graphs::RequestType::GENERIC</code>.</p>
<p>Every information that is needed to process a request (including the graph itself) must be set with the <code>addFieldInformation()</code> function. Its first argument is always the handler information object itself. The second argument specifies the type of the field. This might be the graph itself, information associated with nodes and edges or singular values. A list of possible types can be found in the table below or in the protocol file <code>available_handlers.proto</code> under <code>FieldInformation</code>.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BOOL</code>, <code>DOUBLE</code>, <code>CHOICE</code>, <code>INT</code>, <code>LITERAL</code>, <code>STRING</code></td>
<td>Sets a single entry of the type.</td>
</tr>
<tr>
<td><code>GRAPH</code></td>
<td>Activates the graph entry.</td>
</tr>
<tr>
<td><code>EDGE_COST</code>, <code>VERTEX_COST</code></td>
<td>Sets a weight for each edge or node</td>
</tr>
<tr>
<td><code>EDGE_ID</code>, <code>VERTEX_ID</code></td>
<td>Sets a single entry which must be an edge <br /> or node index.</td>
</tr>
<tr>
<td><code>EDGE_ID_ARRAY</code>, <code>VERTEX_ID_ARRAY</code></td>
<td>Sets an array of edge or node indices.</td>
</tr>
<tr>
<td><code>VERTEX_COORDINATES</code></td>
<td>Activates vertex coordinates.</td>
</tr>
</tbody>
</table>
<p>The third argument given to <code>addFieldInformation()</code> is the name of the field displayed in the frontend, the fourth is the unique internal key of the field. Keys that are not for the graph, node coordinates or edge and node weights must start with <code>graphAttributes.*</code>. The last argument indicates whether this field is required or optional for a request. If omitted, the field is optional by default.</p>
<p>The syntax to add to response fields is nearly identical, in this case the function <code>addResultInformation()</code> is called. Its first argument is, again, the handler information object, its second argument is the type, fourth and fifth are unique name and display name.</p>
<h3 id="constructor">Constructor</h3>
<p>The handler must provide a constructor which takes an <code>std::unique_ptr&lt;abstract_request&gt;</code> as its only argument. This will provide the handler with the request it must answer. The request itself will be processed in the <code>handle</code> function later. In the constructor, the handler can check whether the request is a correct request for the handler and apply preprocessing as needed.</p>
<h3 id="implement-handle">Implement <code>handle()</code></h3>
<p>The function <code>std::pair&lt;graphs::ResponseContainer, long&gt; handle()</code> is called by the server to process the request. It overrides the equivalent pure virtual function of <code>abstract_handler</code>. This function has the purpose to extract the information from the request, call the graph algorithm and then build the response object.</p>
<p>The request consists of a <code>graph_message</code>, which stores the structural information of the graph and of the fields previously set with <code>handler_information()</code>. The <code>graph_message</code> object is immutable and allows access to the graph and gives an index-based view on this graph. The fields in the <code>generic_request</code> are accessed through member functions. Some attributes like node coordinates or weights have specialized functions to allow direct access, others must be accessed through attribute maps. A more in-depth list of access functions is provided via the code documentation.</p>
<p>The return type of <code>handle()</code> is a pair of the response in the form of a <code>graphs::ResponseContainer</code> and a <code>long</code> integer. This integer should represent the time in microseconds the graph algorithm itself needed. The <code>graphs::ResponseContainer</code> is made by the function <code>response_factory::build_response</code>, which takes a <code>generic_response</code>. A <code>generic_response</code> follows the same logic as a <code>generic_request</code>, it contains a <code>graph_message</code> and attributes as arrays and maps.</p>
<h3 id="register-the-handler">Register the Handler</h3>
<p>A handler first needs to be registered so that the server is able to recognize it. This is done in the file <code>src/handling/register_handlers.cpp</code>. Here, the header of the handler file must be included and the class must be registered in the function <code>init_handlers()</code>. For this, the function <code>register_handler()</code> is called with the handler class as template argument.</p>
<p>One optional string can be given to <code>register_handler()</code> as argument. This string is interpreted as a directory structure, where every <code>/</code> signals a new subdirectory.  In this way, handlers can be sorted in categories to be displayed in the frontend. This also applies to every <code>/</code> set in the <code>name()</code> function.</p>
<h3 id="recompile-the-server">Recompile the Server</h3>
<p>Lastly, for the new handler to be active, the server must be recompiled and restarted.</p>
<h2 id="example-kruskal-mst-handler">Example: Kruskal MST Handler</h2>
<p>This section will describe how to add a simple handler for Kruskal's minimum spanning tree algorithm.</p>
<p>The first step is to create <code>include/handling/handlers/kruskal_handler.hpp</code> and <code>src/handling/handlers/kruskal_handler.cpp</code> and add them to <code>src/CMakeLists.txt</code>:</p>
<!-- nochmal überlegen, ob man das im Codeblock oder in einem Bild einfügt-->

<pre><code>set(SERVER_HEADERS
    ${CMAKE_SOURCE_DIR}/include/handling/handler_factory.hpp
</code></pre>
<p><center>
<a name = "cmake1">
    <img alt="ShortestPath" src="../img/cmake1.png" />
</a>
</center></p>
<p>...</p>
<p><center>
<a name = "cmake2">
    <img alt="ShortestPath" src="../img/cmake2.png" />
</a>
</center></p>
<p>Next, we declare the class <code>kruskal_handler</code> in <code>include/handling/handlers/kruskal_handler.hpp</code> as follows:</p>
<p><center>
<a name = "class">
    <img alt="ShortestPath" src="../img/class.png" />
</a>
</center></p>
<p>The class inherits from <code>abstract_handler</code> and implements all functions needed for a handler. The private attribute <code>m_request</code> stores the request given to the constructor for later access.</p>
<p>Now, the functions need to be defined in <code>src/handling/handlers/kruskal_handler.cpp</code>. The first function to implement is <code>name()</code>. </p>
<p><center>
<a name = "name">
    <img alt="ShortestPath" src="../img/name.png" />
</a>
</center></p>
<p>The next function should be <code>handler_information</code>. For Kruskal's algorithm, the algorithm only needs the graph itself and edge weights. To represent the solution later, the coordinates of the nodes are also required. The response should send back a tree in the form of a graph, the coordinates to draw the nodes in QGIS and the edge weights of the surviving edges. The resulting function should look like this:</p>
<p><center>
<a name = "handlerInfo">
    <img alt="ShortestPath" src="../img/handler_info.png" />
</a>
</center></p>
<p>The constructor takes an <code>abstract_request</code> and tries to cast it into a generic request.</p>
<pre><code>kruskal_handler::kruskal_handler(std::unique_ptr&lt;abstract_request&gt; request)
{
    if(const auto *type_check_ptr = dynamic_cast&lt;generic_request *&gt;(request.get());
    {
        throw server::request_parse_error("kruskal_handler: dynamic_cast failed!", request-&gt;type(), name());
    }
    m_request = std::unique_ptr&lt;generic_request&gt;{static_cast&lt;generic_request *&gt;(request.release())};
}
</code></pre>
<p><center>
<a name = "constructor">
    <img alt="ShortestPath" src="../img/constructor.png" />
</a>
</center></p>
<p>Now, the <code>handle()</code> function does several things. First, all information needs to be copied into a new graph (because the graph from the request is immutable and the algorithm cuts edges):</p>
<p><center>
<a name = "handle1">
    <img alt="ShortestPath" src="../img/handle1.png" />
</a>
</center></p>
<p>Then, the function <code>makeMinimumSpanningTree()</code> from the OGDF is called and its runtime is measured:</p>
<p><center>
<a name = "handle2">
    <img alt="ShortestPath" src="../img/handle2.png" />
</a>
</center></p>
<p>Finally, the result is packed into a response object:</p>
<p><center>
<a name = "handle3">
    <img alt="ShortestPath" src="../img/handle3.png" />
</a>
</center></p>
<p>The new handler must then be registered in the function <code>init_handlers()</code> in <code>src/handling/register_handlers.cpp</code>:</p>
<p><center>
<a name = "register">
    <img alt="ShortestPath" src="../img/register.png" />
</a>
</center></p>
<p>In the OGDF plugin, the new handler now appears under the category <em>Minimum Spanning Trees</em>.</p>
<p>The entire code of this example (and also some other example handlers) is implemented in the backend repository. The files can be found under <code>include/handling/handlers/kruskal_handler.hpp</code> and <code>src/handling/handlers/kruskal_handler.cpp</code>.</p>
<h2 id="specialized-handlers">Specialized Handlers</h2>
<p>It is also possible to create specialized handlers for complicated use cases not covered by generic handlers. This, however, would involve changing and expanding server, frontend and protocol code. It is out of the scope of this handbook to provide instructions on this, but the possibility should be noted here.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../testing/" class="btn btn-neutral float-right" title="Testing Your Results">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../graphlayer/" class="btn btn-neutral" title="Graph Layer"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../graphlayer/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../testing/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../js/print-site.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(false);
        };
    </script>

</body>
</html>
